{"version":3,"sources":["webpack:///latex-mode.bundle.js","webpack:///./node_modules/brace/mode/latex.js"],"names":["webpackJsonpTexteditor","./node_modules/brace/mode/latex.js","module","exports","ace","define","acequire","oop","TextHighlightRules","LatexHighlightRules","this","$rules","start","token","regex","next","equation","defaultToken","verbatim","lstlisting","normalizeRules","inherits","BaseFoldMode","FoldMode","Range","TokenIterator","keywordLevels","\\subparagraph","\\paragraph","\\subsubsubsection","\\subsubsection","\\subsection","\\section","\\chapter","\\part","\\begin","\\end","foldingStartMarker","foldingStopMarker","getFoldWidgetRange","session","foldStyle","row","line","doc","getLine","match","exec","latexBlock","length","latexSection","openingBracketBlock","index","closingBracketBlock","column","returnRange","keywords","stream","getCurrentToken","type","val","value","dir","getType","stepForward","stepBackward","stack","startColumn","getCurrentTokenColumn","startRow","step","level","unshift","shift","getCurrentTokenRange","getCurrentTokenRow","startLevel","stackDepth","endRow","test","call","prototype","TextMode","Mode","CstyleBehaviour","LatexFoldMode","HighlightRules","foldingRules","$behaviour","braces","lineCommentStart","$id","getMatching","undefined","selection","lead","startToken","getTokenAt"],"mappings":"AAAAA,wBAAwB,KAElBC,qCACA,SAAUC,EAAQC,GCHxBC,IAAAC,OAAA,uHAAAC,EAAAH,EAAAD,GACA,YAEA,IAAAK,GAAAD,EAAA,cACAE,EAAAF,EAAA,0BAAAE,mBAEAC,EAAA,WAEAC,KAAAC,QACAC,QACAC,MAAA,UACAC,MAAA,SAEAD,OAAA,mFACAC,MAAA,kFAEAD,OAAA,kDACAC,MAAA,0DAEAD,OAAA,uDACAC,MAAA,8BACAC,KAAA,aAEAF,OAAA,uDACAC,MAAA,gCACAC,KAAA,eAEAF,OAAA,uDACAC,MAAA,uCAEAD,MAAA,eACAC,MAAA,cACAC,OACAF,OAAA,gDACAC,MAAA,mBACAC,KAAA,YAGAF,MAAA,eACAC,MAAA,kBAEAD,MAAA,SACAC,MAAA,UAEAD,MAAA,SACAC,MAAA,YAEAD,MAAA,4BACAC,MAAA,mBAEAD,MAAA,SACAC,MAAA,WACAC,KAAA,aAEAC,WACAH,MAAA,UACAC,MAAA,SAEAD,MAAA,SACAC,MAAA,WACAC,KAAA,UAEAF,MAAA,4BACAC,MAAA,gCAEAD,MAAA,QACAC,MAAA,SACAC,KAAA,UAEAE,aAAA,WAEAC,WACAL,OAAA,uDACAC,MAAA,4BACAC,KAAA,UAEAE,aAAA,SAEAE,aACAN,OAAA,uDACAC,MAAA,8BACAC,KAAA,UAEAE,aAAA,UAIAP,KAAAU,iBAEAb,GAAAc,SAAAZ,EAAAD,GAEAL,EAAAM,wBAIAL,IAAAC,OAAA,6IAAAC,EAAAH,EAAAD,GACA,YAEA,IAAAK,GAAAD,EAAA,iBACAgB,EAAAhB,EAAA,eAAAiB,SACAC,EAAAlB,EAAA,eAAAkB,MACAC,EAAAnB,EAAA,wBAAAmB,cACAC,GACAC,iBAAA,EACAC,cAAA,EACAC,qBAAA,EACAC,kBAAA,EACAC,eAAA,EACAC,YAAA,EACAC,YAAA,EACAC,SAAA,EACAC,UAAA,EACAC,QAAA,IAGAb,EAAApB,EAAAoB,SAAA,YAEAhB,GAAAc,SAAAE,EAAAD,GAEA,WAEAZ,KAAA2B,mBAAA,0EACA3B,KAAA4B,kBAAA,sBAEA5B,KAAA6B,mBAAA,SAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAH,EAAAI,IAAAC,QAAAH,GACAI,EAAApC,KAAA2B,mBAAAU,KAAAJ,EACA,IAAAG,EACA,MAAAA,GAAA,GACApC,KAAAsC,WAAAR,EAAAE,EAAAI,EAAA,GAAAG,OAAA,GACAH,EAAA,GACApC,KAAAwC,aAAAV,EAAAE,EAAAI,EAAA,GAAAG,OAAA,GAEAvC,KAAAyC,oBAAAX,EAAA,IAAuDE,EAAAI,EAAAM,MAGvD,IAAAN,GAAApC,KAAA4B,kBAAAS,KAAAJ,EACA,OAAAG,GACAA,EAAA,GACApC,KAAAsC,WAAAR,EAAAE,EAAAI,EAAA,GAAAG,OAAA,GAEAvC,KAAA2C,oBAAAb,EAAA,IAAuDE,EAAAI,EAAAM,MAAAN,EAAA,GAAAG,YAJvD,IAQAvC,KAAAsC,WAAA,SAAAR,EAAAE,EAAAY,EAAAC,GACA,GAAAC,IACArB,UAAA,EACAC,SAAA,GAGAqB,EAAA,GAAAhC,GAAAe,EAAAE,EAAAY,GACAzC,EAAA4C,EAAAC,iBACA,IAAA7C,IAAA,gBAAAA,EAAA8C,MAAA,6BAAA9C,EAAA8C,MAAA,CAGA,GAAAC,GAAA/C,EAAAgD,MACAC,EAAAN,EAAAI,GAEAG,EAAA,WACA,GAAAlD,GAAA4C,EAAAO,cACAL,EAAA,UAAA9C,EAAA8C,KAAAF,EAAAO,cAAAH,MAAA,EAMA,QALA,IAAAC,IACAL,EAAAQ,eACAN,GACAF,EAAAQ,gBAEAN,GAEAO,GAAAH,KACAI,GAAA,IAAAL,EAAAL,EAAAW,wBAAA5B,EAAAK,QAAAH,GAAAO,OACAoB,EAAA3B,CAGA,KADAe,EAAAa,MAAA,IAAAR,EAAAL,EAAAQ,aAAAR,EAAAO,YACAnD,EAAA4C,EAAAa,QACA,GAAAzD,IAAA,gBAAAA,EAAA8C,MAAA,6BAAA9C,EAAA8C,MAAA,CAEA,GAAAY,GAAAf,EAAA3C,EAAAgD,MACA,IAAAU,EAAA,CAEA,GAAAZ,GAAAI,GACA,IAAAQ,IAAAT,EACAI,EAAAM,QAAAb,OACA,IAAAO,EAAAO,UAAAd,IAAAO,EAAAjB,OACA,OAGA,IAAAiB,EAAAjB,OAAA,CAQA,GALA,GAAAa,IACAL,EAAAQ,eACAR,EAAAQ,gBAGAV,EACA,MAAAE,GAAAiB,sBAEA,IAAAhC,GAAAe,EAAAkB,oBACA,YAAAb,EACA,GAAAtC,GAAAkB,EAAAF,EAAAK,QAAAH,GAAAO,OAAAoB,EAAAF,GAEA,GAAA3C,GAAA6C,EAAAF,EAAAzB,EAAAe,EAAAW,4BAGA1D,KAAAwC,aAAA,SAAAV,EAAAE,EAAAY,GACA,GAAAG,GAAA,GAAAhC,GAAAe,EAAAE,EAAAY,GACAzC,EAAA4C,EAAAC,iBACA,IAAA7C,GAAA,gBAAAA,EAAA8C,KAAA,CAOA,IAJA,GAAAiB,GAAAlD,EAAAb,EAAAgD,QAAA,EACAgB,EAAA,EACAC,EAAApC,EAEA7B,EAAA4C,EAAAO,eACA,oBAAAnD,EAAA8C,KAAA,CAEA,GAAAY,GAAA7C,EAAAb,EAAAgD,QAAA,CAEA,IAAAU,GAAA,GAIA,GAHAM,IACAC,EAAArB,EAAAkB,qBAAA,IACAE,GAAA,GAAAN,EAAA,MACA,EACA,UACa,IAAAA,GAAAK,EACb,MAMA,IAHAC,IACAC,EAAArB,EAAAkB,qBAAA,GAEAG,EAAApC,IAAA,KAAAqC,KAAAvC,EAAAK,QAAAiC,KACAA,GAEA,WAAAtD,GACAkB,EAAAF,EAAAK,QAAAH,GAAAO,OACA6B,EAAAtC,EAAAK,QAAAiC,GAAA7B,WAIC+B,KAAAzD,EAAA0D,aAID7E,IAAAC,OAAA,6KAAAC,EAAAH,EAAAD,GACA,YAEA,IAAAK,GAAAD,EAAA,cACA4E,EAAA5E,EAAA,UAAA6E,KACA1E,EAAAH,EAAA,2BAAAG,oBACA2E,EAAA9E,EAAA,sBAAA8E,gBACAC,EAAA/E,EAAA,mBAAAiB,SAEA4D,EAAA,WACAzE,KAAA4E,eAAA7E,EACAC,KAAA6E,aAAA,GAAAF,GACA3E,KAAA8E,WAAA,GAAAJ,IAA2CK,QAAA,IAE3ClF,GAAAc,SAAA8D,EAAAD,GAEA,WACAxE,KAAAiD,KAAA,OAEAjD,KAAAgF,iBAAA,IAEAhF,KAAAiF,IAAA,iBAEAjF,KAAAkF,YAAA,SAAApD,EAAAE,EAAAY,OACAuC,IAAAnD,IACAA,EAAAF,EAAAsD,UAAAC,MACA,gBAAArD,KACAY,EAAAZ,EAAAY,OACAZ,QAGA,IAAAsD,GAAAxD,EAAAyD,WAAAvD,EAAAY,EACA,IAAA0C,EAEA,iBAAAA,EAAAnC,OAAA,SAAAmC,EAAAnC,MACAnD,KAAA6E,aAAAvC,WAAAR,EAAAE,EAAAY,GAAA,OADA,KAIC0B,KAAAG,EAAAF,WAED9E,EAAAgF","file":"latex-mode.bundle.js","sourcesContent":["webpackJsonpTexteditor([26],{\n\n/***/ \"./node_modules/brace/mode/latex.js\":\n/***/ (function(module, exports) {\n\nace.define(\"ace/mode/latex_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\nvar LatexHighlightRules = function() {  \n\n    this.$rules = {\n        \"start\" : [{\n            token : \"comment\",\n            regex : \"%.*$\"\n        }, {\n            token : [\"keyword\", \"lparen\", \"variable.parameter\", \"rparen\", \"lparen\", \"storage.type\", \"rparen\"],\n            regex : \"(\\\\\\\\(?:documentclass|usepackage|input))(?:(\\\\[)([^\\\\]]*)(\\\\]))?({)([^}]*)(})\"\n        }, {\n            token : [\"keyword\",\"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\(?:label|v?ref|cite(?:[^{]*)))(?:({)([^}]*)(}))?\"\n        }, {\n            token : [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\begin)({)(verbatim)(})\",\n            next : \"verbatim\"\n        },  {\n            token : [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\begin)({)(lstlisting)(})\",\n            next : \"lstlisting\"\n        },  {\n            token : [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\(?:begin|end))({)([\\\\w*]*)(})\"\n        }, {\n            token : \"storage.type\",\n            regex : /\\\\verb\\b\\*?/,\n            next : [{\n                token : [\"keyword.operator\", \"string\", \"keyword.operator\"],\n                regex : \"(.)(.*?)(\\\\1|$)|\",\n                next : \"start\"\n            }]\n        }, {\n            token : \"storage.type\",\n            regex : \"\\\\\\\\[a-zA-Z]+\"\n        }, {\n            token : \"lparen\",\n            regex : \"[[({]\"\n        }, {\n            token : \"rparen\",\n            regex : \"[\\\\])}]\"\n        }, {\n            token : \"constant.character.escape\",\n            regex : \"\\\\\\\\[^a-zA-Z]?\"\n        }, {\n            token : \"string\",\n            regex : \"\\\\${1,2}\",\n            next  : \"equation\"\n        }],\n        \"equation\" : [{\n            token : \"comment\",\n            regex : \"%.*$\"\n        }, {\n            token : \"string\",\n            regex : \"\\\\${1,2}\",\n            next  : \"start\"\n        }, {\n            token : \"constant.character.escape\",\n            regex : \"\\\\\\\\(?:[^a-zA-Z]|[a-zA-Z]+)\"\n        }, {\n            token : \"error\", \n            regex : \"^\\\\s*$\", \n            next : \"start\" \n        }, {\n            defaultToken : \"string\"\n        }],\n        \"verbatim\": [{\n            token : [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\end)({)(verbatim)(})\",\n            next : \"start\"\n        }, {\n            defaultToken : \"text\"\n        }],\n        \"lstlisting\": [{\n            token : [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\end)({)(lstlisting)(})\",\n            next : \"start\"\n        }, {\n            defaultToken : \"text\"\n        }]\n    };\n\n    this.normalizeRules();\n};\noop.inherits(LatexHighlightRules, TextHighlightRules);\n\nexports.LatexHighlightRules = LatexHighlightRules;\n\n});\n\nace.define(\"ace/mode/folding/latex\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\",\"ace/token_iterator\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../../lib/oop\");\nvar BaseFoldMode = acequire(\"./fold_mode\").FoldMode;\nvar Range = acequire(\"../../range\").Range;\nvar TokenIterator = acequire(\"../../token_iterator\").TokenIterator;\nvar keywordLevels = {\n    \"\\\\subparagraph\": 1,\n    \"\\\\paragraph\": 2,\n    \"\\\\subsubsubsection\": 3,\n    \"\\\\subsubsection\": 4,\n    \"\\\\subsection\": 5,\n    \"\\\\section\": 6,\n    \"\\\\chapter\": 7,\n    \"\\\\part\": 8,\n    \"\\\\begin\": 9,\n    \"\\\\end\": 10\n};\n\nvar FoldMode = exports.FoldMode = function() {};\n\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n\n    this.foldingStartMarker = /^\\s*\\\\(begin)|\\s*\\\\(part|chapter|(?:sub)*(?:section|paragraph))\\b|{\\s*$/;\n    this.foldingStopMarker = /^\\s*\\\\(end)\\b|^\\s*}/;\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var line = session.doc.getLine(row);\n        var match = this.foldingStartMarker.exec(line);\n        if (match) {\n            if (match[1])\n                return this.latexBlock(session, row, match[0].length - 1);\n            if (match[2])\n                return this.latexSection(session, row, match[0].length - 1);\n\n            return this.openingBracketBlock(session, \"{\", row, match.index);\n        }\n\n        var match = this.foldingStopMarker.exec(line);\n        if (match) {\n            if (match[1])\n                return this.latexBlock(session, row, match[0].length - 1);\n\n            return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n        }\n    };\n\n    this.latexBlock = function(session, row, column, returnRange) {\n        var keywords = {\n            \"\\\\begin\": 1,\n            \"\\\\end\": -1\n        };\n\n        var stream = new TokenIterator(session, row, column);\n        var token = stream.getCurrentToken();\n        if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\"))\n            return;\n\n        var val = token.value;\n        var dir = keywords[val];\n\n        var getType = function() {\n            var token = stream.stepForward();\n            var type = token.type == \"lparen\" ?stream.stepForward().value : \"\";\n            if (dir === -1) {\n                stream.stepBackward();\n                if (type)\n                    stream.stepBackward();\n            }\n            return type;\n        };\n        var stack = [getType()];\n        var startColumn = dir === -1 ? stream.getCurrentTokenColumn() : session.getLine(row).length;\n        var startRow = row;\n\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n        while(token = stream.step()) {\n            if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\"))\n                continue;\n            var level = keywords[token.value];\n            if (!level)\n                continue;\n            var type = getType();\n            if (level === dir)\n                stack.unshift(type);\n            else if (stack.shift() !== type || !stack.length)\n                break;\n        }\n\n        if (stack.length)\n            return;\n\n        if (dir == 1) {\n            stream.stepBackward();\n            stream.stepBackward();\n        }\n\n        if (returnRange)\n            return stream.getCurrentTokenRange();\n\n        var row = stream.getCurrentTokenRow();\n        if (dir === -1)\n            return new Range(row, session.getLine(row).length, startRow, startColumn);\n        else\n            return new Range(startRow, startColumn, row, stream.getCurrentTokenColumn());\n    };\n\n    this.latexSection = function(session, row, column) {\n        var stream = new TokenIterator(session, row, column);\n        var token = stream.getCurrentToken();\n        if (!token || token.type != \"storage.type\")\n            return;\n\n        var startLevel = keywordLevels[token.value] || 0;\n        var stackDepth = 0;\n        var endRow = row;\n\n        while(token = stream.stepForward()) {\n            if (token.type !== \"storage.type\")\n                continue;\n            var level = keywordLevels[token.value] || 0;\n\n            if (level >= 9) {\n                if (!stackDepth)\n                    endRow = stream.getCurrentTokenRow() - 1;\n                stackDepth += level == 9 ? 1 : - 1;\n                if (stackDepth < 0)\n                    break;\n            } else if (level >= startLevel)\n                break;\n        }\n\n        if (!stackDepth)\n            endRow = stream.getCurrentTokenRow() - 1;\n\n        while (endRow > row && !/\\S/.test(session.getLine(endRow)))\n            endRow--;\n\n        return new Range(\n            row, session.getLine(row).length,\n            endRow, session.getLine(endRow).length\n        );\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/latex\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/latex_highlight_rules\",\"ace/mode/behaviour/cstyle\",\"ace/mode/folding/latex\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextMode = acequire(\"./text\").Mode;\nvar LatexHighlightRules = acequire(\"./latex_highlight_rules\").LatexHighlightRules;\nvar CstyleBehaviour = acequire(\"./behaviour/cstyle\").CstyleBehaviour;\nvar LatexFoldMode = acequire(\"./folding/latex\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = LatexHighlightRules;\n    this.foldingRules = new LatexFoldMode();\n    this.$behaviour = new CstyleBehaviour({ braces: true });\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n    this.type = \"text\";\n    \n    this.lineCommentStart = \"%\";\n\n    this.$id = \"ace/mode/latex\";\n\n    this.getMatching = function(session, row, column) {\n        if (row == undefined)\n            row = session.selection.lead;\n        if (typeof row == \"object\") {\n            column = row.column;\n            row = row.row;\n        }\n\n        var startToken = session.getTokenAt(row, column);\n        if (!startToken)\n            return;\n        if (startToken.value == \"\\\\begin\" || startToken.value == \"\\\\end\") {\n            return this.foldingRules.latexBlock(session, row, column, true);\n        }\n    };\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n\n});\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// latex-mode.bundle.js","ace.define(\"ace/mode/latex_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\nvar LatexHighlightRules = function() {  \n\n    this.$rules = {\n        \"start\" : [{\n            token : \"comment\",\n            regex : \"%.*$\"\n        }, {\n            token : [\"keyword\", \"lparen\", \"variable.parameter\", \"rparen\", \"lparen\", \"storage.type\", \"rparen\"],\n            regex : \"(\\\\\\\\(?:documentclass|usepackage|input))(?:(\\\\[)([^\\\\]]*)(\\\\]))?({)([^}]*)(})\"\n        }, {\n            token : [\"keyword\",\"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\(?:label|v?ref|cite(?:[^{]*)))(?:({)([^}]*)(}))?\"\n        }, {\n            token : [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\begin)({)(verbatim)(})\",\n            next : \"verbatim\"\n        },  {\n            token : [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\begin)({)(lstlisting)(})\",\n            next : \"lstlisting\"\n        },  {\n            token : [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\(?:begin|end))({)([\\\\w*]*)(})\"\n        }, {\n            token : \"storage.type\",\n            regex : /\\\\verb\\b\\*?/,\n            next : [{\n                token : [\"keyword.operator\", \"string\", \"keyword.operator\"],\n                regex : \"(.)(.*?)(\\\\1|$)|\",\n                next : \"start\"\n            }]\n        }, {\n            token : \"storage.type\",\n            regex : \"\\\\\\\\[a-zA-Z]+\"\n        }, {\n            token : \"lparen\",\n            regex : \"[[({]\"\n        }, {\n            token : \"rparen\",\n            regex : \"[\\\\])}]\"\n        }, {\n            token : \"constant.character.escape\",\n            regex : \"\\\\\\\\[^a-zA-Z]?\"\n        }, {\n            token : \"string\",\n            regex : \"\\\\${1,2}\",\n            next  : \"equation\"\n        }],\n        \"equation\" : [{\n            token : \"comment\",\n            regex : \"%.*$\"\n        }, {\n            token : \"string\",\n            regex : \"\\\\${1,2}\",\n            next  : \"start\"\n        }, {\n            token : \"constant.character.escape\",\n            regex : \"\\\\\\\\(?:[^a-zA-Z]|[a-zA-Z]+)\"\n        }, {\n            token : \"error\", \n            regex : \"^\\\\s*$\", \n            next : \"start\" \n        }, {\n            defaultToken : \"string\"\n        }],\n        \"verbatim\": [{\n            token : [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\end)({)(verbatim)(})\",\n            next : \"start\"\n        }, {\n            defaultToken : \"text\"\n        }],\n        \"lstlisting\": [{\n            token : [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\end)({)(lstlisting)(})\",\n            next : \"start\"\n        }, {\n            defaultToken : \"text\"\n        }]\n    };\n\n    this.normalizeRules();\n};\noop.inherits(LatexHighlightRules, TextHighlightRules);\n\nexports.LatexHighlightRules = LatexHighlightRules;\n\n});\n\nace.define(\"ace/mode/folding/latex\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\",\"ace/token_iterator\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../../lib/oop\");\nvar BaseFoldMode = acequire(\"./fold_mode\").FoldMode;\nvar Range = acequire(\"../../range\").Range;\nvar TokenIterator = acequire(\"../../token_iterator\").TokenIterator;\nvar keywordLevels = {\n    \"\\\\subparagraph\": 1,\n    \"\\\\paragraph\": 2,\n    \"\\\\subsubsubsection\": 3,\n    \"\\\\subsubsection\": 4,\n    \"\\\\subsection\": 5,\n    \"\\\\section\": 6,\n    \"\\\\chapter\": 7,\n    \"\\\\part\": 8,\n    \"\\\\begin\": 9,\n    \"\\\\end\": 10\n};\n\nvar FoldMode = exports.FoldMode = function() {};\n\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n\n    this.foldingStartMarker = /^\\s*\\\\(begin)|\\s*\\\\(part|chapter|(?:sub)*(?:section|paragraph))\\b|{\\s*$/;\n    this.foldingStopMarker = /^\\s*\\\\(end)\\b|^\\s*}/;\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var line = session.doc.getLine(row);\n        var match = this.foldingStartMarker.exec(line);\n        if (match) {\n            if (match[1])\n                return this.latexBlock(session, row, match[0].length - 1);\n            if (match[2])\n                return this.latexSection(session, row, match[0].length - 1);\n\n            return this.openingBracketBlock(session, \"{\", row, match.index);\n        }\n\n        var match = this.foldingStopMarker.exec(line);\n        if (match) {\n            if (match[1])\n                return this.latexBlock(session, row, match[0].length - 1);\n\n            return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n        }\n    };\n\n    this.latexBlock = function(session, row, column, returnRange) {\n        var keywords = {\n            \"\\\\begin\": 1,\n            \"\\\\end\": -1\n        };\n\n        var stream = new TokenIterator(session, row, column);\n        var token = stream.getCurrentToken();\n        if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\"))\n            return;\n\n        var val = token.value;\n        var dir = keywords[val];\n\n        var getType = function() {\n            var token = stream.stepForward();\n            var type = token.type == \"lparen\" ?stream.stepForward().value : \"\";\n            if (dir === -1) {\n                stream.stepBackward();\n                if (type)\n                    stream.stepBackward();\n            }\n            return type;\n        };\n        var stack = [getType()];\n        var startColumn = dir === -1 ? stream.getCurrentTokenColumn() : session.getLine(row).length;\n        var startRow = row;\n\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n        while(token = stream.step()) {\n            if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\"))\n                continue;\n            var level = keywords[token.value];\n            if (!level)\n                continue;\n            var type = getType();\n            if (level === dir)\n                stack.unshift(type);\n            else if (stack.shift() !== type || !stack.length)\n                break;\n        }\n\n        if (stack.length)\n            return;\n\n        if (dir == 1) {\n            stream.stepBackward();\n            stream.stepBackward();\n        }\n\n        if (returnRange)\n            return stream.getCurrentTokenRange();\n\n        var row = stream.getCurrentTokenRow();\n        if (dir === -1)\n            return new Range(row, session.getLine(row).length, startRow, startColumn);\n        else\n            return new Range(startRow, startColumn, row, stream.getCurrentTokenColumn());\n    };\n\n    this.latexSection = function(session, row, column) {\n        var stream = new TokenIterator(session, row, column);\n        var token = stream.getCurrentToken();\n        if (!token || token.type != \"storage.type\")\n            return;\n\n        var startLevel = keywordLevels[token.value] || 0;\n        var stackDepth = 0;\n        var endRow = row;\n\n        while(token = stream.stepForward()) {\n            if (token.type !== \"storage.type\")\n                continue;\n            var level = keywordLevels[token.value] || 0;\n\n            if (level >= 9) {\n                if (!stackDepth)\n                    endRow = stream.getCurrentTokenRow() - 1;\n                stackDepth += level == 9 ? 1 : - 1;\n                if (stackDepth < 0)\n                    break;\n            } else if (level >= startLevel)\n                break;\n        }\n\n        if (!stackDepth)\n            endRow = stream.getCurrentTokenRow() - 1;\n\n        while (endRow > row && !/\\S/.test(session.getLine(endRow)))\n            endRow--;\n\n        return new Range(\n            row, session.getLine(row).length,\n            endRow, session.getLine(endRow).length\n        );\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/latex\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/latex_highlight_rules\",\"ace/mode/behaviour/cstyle\",\"ace/mode/folding/latex\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextMode = acequire(\"./text\").Mode;\nvar LatexHighlightRules = acequire(\"./latex_highlight_rules\").LatexHighlightRules;\nvar CstyleBehaviour = acequire(\"./behaviour/cstyle\").CstyleBehaviour;\nvar LatexFoldMode = acequire(\"./folding/latex\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = LatexHighlightRules;\n    this.foldingRules = new LatexFoldMode();\n    this.$behaviour = new CstyleBehaviour({ braces: true });\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n    this.type = \"text\";\n    \n    this.lineCommentStart = \"%\";\n\n    this.$id = \"ace/mode/latex\";\n\n    this.getMatching = function(session, row, column) {\n        if (row == undefined)\n            row = session.selection.lead;\n        if (typeof row == \"object\") {\n            column = row.column;\n            row = row.row;\n        }\n\n        var startToken = session.getTokenAt(row, column);\n        if (!startToken)\n            return;\n        if (startToken.value == \"\\\\begin\" || startToken.value == \"\\\\end\") {\n            return this.foldingRules.latexBlock(session, row, column, true);\n        }\n    };\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/brace/mode/latex.js\n// module id = ./node_modules/brace/mode/latex.js\n// module chunks = 26"],"sourceRoot":""}